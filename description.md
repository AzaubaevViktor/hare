ПРОГРАММА МАКСИМУМ
==================
```
hare -[axdlt] arc[.ext] [file1] [file2]

1   -a: добавить в архив
        При существовании файла в архиве вопрос о замене
        Если файла не существует, сказать об этом, рассказать про -a и про то, что его нужно добавить

1   -x: извлечь
        При существовании вопрос о замене
        Время хранения файла тоже нужно!

    -d: удалить
        При удалении несуществующего вопрос

1   -l: список файлов (дерево)

    -t: проверка целостности
        Контрольные суммы! (предложил crc32)


1 -- миннимум
```

РАЗБОР АРГУМЕНТОВ
=================
1. Разбор аргументов
    * Ключи
    * Список файлов
    * Имя архива
2. Проверки
    * Существует ли архив
    * Можно ли изменять архив
    * Можно ли прочитать
    * Проверка сигнатуры


СТРУКТУРА
=========

<СИГНАТУРА>
```
1. Заголовок (есть вариант хранить это ??бинарным деревом?? по именам для поиска, вопрос что делать при удалении?)
    * размер заголовка int64 (считать с ним или без?)
    * Длинна имени int64
    * имя'\0'
    * Время создания 8 байт int64
    * Оригинальная длинна int64
    * Сжатая длинна int64 (для относительной адресации)
    * Кол-во неиспользованных бит в последнем байте DATA char 
    * Флаги
        : Сжат/Несжат 1bit
        : Файл из одного символа 1bit ( ? зависит от реализации ? )
    * Размер дерева Хаффмана int64
    * Дерево Хаффмана !
    * Контрольная сумма (Заголовок)
    * Контрольная сумма (DATA)
DATA
2. Заголовок
DATA
...
```

Восстановление -- перед заголовком сигнатура

Контрольные суммы
=================
При записи\стении передавать указатель на контрольную сумму, если указатель == NULL, то не считать контрольную сумму

Вариант архивирования
=====================
Составление таблицы частот -- считывание всего файла
    Считывание блоками
    параллельно считать контрольную сумму CRC32
Генерация дерева
Получение кода !

Запись:
    Поблоковая с fflush


БУФЕРА
======
    * `input byte, [V,...]`
    * `output byte, bit  []`
если остаются неиспользованные, это нужно хранить   
Потоково считать контрольную сумму   
Аналогично для декодирования


ХРАНЕНИЕ ДЕРЕВА
===============
Частота встречаемости байтов
```
Символ -> Частота, код
   V
Символ -> Частота, код
   V
  ...
```
1. Считается частота
2. Строится дерево
3. Генерация кода


ЛОГИРОВАНИЕ В ТЕСТОВЫХ СБОРКАХ (велосипед)!   
=========
Типы сообщений:  
```
INFO    
    * функция начала работать и закончила работать, остальная информация    
MEMORY    
    * выделение, освобождение памяти    
IO    
    * Работа с файлами на уровне системы, запись/чтение данных ( DEEP_LOGING для досконально )    
ERROR    
    * Остальные ошибки    
WARNING    
    * Не прерывает работу программы, но меняет её поведение в некотором участке    
```


Передавать переменные большшой структурой или отдельно????? == Использовать ли контекст?
ИМЯ ФАЙЛА (при добавлении файла -- добавляем в корень, а если попросят -- в папку, при добавлении папки -- папку+все файлы из неё)?   
НУЖЕН ТРЕКЕР (GitHub)!   
НУЖНО МОДУЛЬНОЕ ТЕСТИРОВАНИЕ (C_Tested)!   
Нужно целостное тестирование программы (проверка файлов на совпадение, велосипед? на bash)   
НУЖЕН ДЕТЕКТ BIG ENDIAN и LITTLE ENDIAN!   ЗАПИСЬ ЦЕЛОГО == НА ЛЕТУ

